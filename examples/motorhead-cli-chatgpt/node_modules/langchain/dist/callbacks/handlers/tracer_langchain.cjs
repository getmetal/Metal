"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LangChainTracer = void 0;
const uuid = __importStar(require("uuid"));
const tracer_js_1 = require("./tracer.cjs");
class LangChainTracer extends tracer_js_1.BaseTracer {
    constructor(exampleId, tenantId) {
        super();
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "langchain_tracer"
        });
        Object.defineProperty(this, "endpoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (typeof process !== "undefined"
                ? // eslint-disable-next-line no-process-env
                    process.env?.LANGCHAIN_ENDPOINT
                : undefined) || "http://localhost:8000"
        });
        Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {
                "Content-Type": "application/json",
            }
        });
        Object.defineProperty(this, "session", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "exampleId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tenantId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // eslint-disable-next-line no-process-env
        if (typeof process !== "undefined" && process.env?.LANGCHAIN_API_KEY) {
            // eslint-disable-next-line no-process-env
            this.headers["x-api-key"] = process.env?.LANGCHAIN_API_KEY;
        }
        this.tenantId =
            tenantId ??
                (typeof process !== "undefined"
                    ? // eslint-disable-next-line no-process-env
                        process.env?.LANGCHAIN_TENANT_ID
                    : undefined);
        this.exampleId = exampleId;
    }
    async newSession(sessionName) {
        const tenantId = this.tenantId ?? (await this.updateTenantId());
        const sessionCreate = {
            start_time: Date.now(),
            name: sessionName,
            tenant_id: tenantId,
        };
        const session = await this.persistSession(sessionCreate);
        this.session = session;
        return session;
    }
    async loadSession(sessionName) {
        const endpoint = `${this.endpoint}/sessions?name=${sessionName}`;
        return this._handleSessionResponse(endpoint);
    }
    async loadDefaultSession() {
        const endpoint = `${this.endpoint}/sessions?name=default`;
        return this._handleSessionResponse(endpoint);
    }
    async persistSession(sessionCreate) {
        const endpoint = `${this.endpoint}/sessions`;
        const tenant_id = this.tenantId ?? (await this.updateTenantId());
        const response = await fetch(endpoint, {
            method: "POST",
            headers: this.headers,
            body: JSON.stringify(sessionCreate),
        });
        if (!response.ok) {
            if (sessionCreate.name !== undefined) {
                return await this.loadSession(sessionCreate.name);
            }
            else {
                return await this.loadDefaultSession();
            }
        }
        return {
            id: (await response.json()).id,
            tenant_id,
            ...sessionCreate,
        };
    }
    async updateTenantId() {
        const endpoint = `${this.endpoint}/tenants`;
        const response = await fetch(endpoint, {
            method: "GET",
            headers: this.headers,
        });
        if (!response.ok) {
            throw new Error(`Failed to fetch tenant ID: ${response.status} ${response.statusText}`);
        }
        const tenants = await response.json();
        if (!tenants || tenants.length === 0) {
            throw new Error(`No tenants found for endpoint ${endpoint}`);
        }
        const tenantId = tenants[0].id;
        this.tenantId = tenantId;
        return tenantId;
    }
    async _handleSessionResponse(endpoint) {
        const tenantId = this.tenantId ?? (await this.updateTenantId());
        const configured_endpoint = `${endpoint}&tenant_id=${this.tenantId}`;
        const response = await fetch(configured_endpoint, {
            method: "GET",
            headers: this.headers,
        });
        let tracerSession;
        if (!response.ok) {
            throw new Error(`Failed to fetch session: ${response.status} ${response.statusText}`);
        }
        const resp = (await response.json());
        if (resp.length === 0) {
            tracerSession = {
                id: uuid.v4(),
                start_time: Date.now(),
                tenant_id: tenantId,
            };
            this.session = tracerSession;
            return tracerSession;
        }
        [tracerSession] = resp;
        this.session = tracerSession;
        return tracerSession;
    }
    async _convertToCreate(run, example_id = undefined) {
        const session = this.session ?? (await this.loadDefaultSession());
        const persistedRun = {
            id: run.id,
            name: run.name,
            start_time: run.start_time,
            end_time: run.end_time,
            run_type: run.run_type,
            reference_example_id: example_id,
            extra: run.extra ?? {},
            execution_order: run.execution_order,
            serialized: run.serialized,
            error: run.error,
            inputs: run.inputs,
            outputs: run.outputs ?? {},
            session_id: session.id,
            child_runs: await Promise.all(run.child_runs.map((child_run) => this._convertToCreate(child_run))),
        };
        return persistedRun;
    }
    async persistRun(run) {
        const persistedRun = await this._convertToCreate(run, this.exampleId);
        const endpoint = `${this.endpoint}/runs`;
        const response = await fetch(endpoint, {
            method: "POST",
            headers: this.headers,
            body: JSON.stringify(persistedRun),
        });
        if (!response.ok) {
            console.error(`Failed to persist run: ${response.status} ${response.statusText}`);
        }
    }
}
exports.LangChainTracer = LangChainTracer;
